---
title: "GraphQL"
emoji: "ğŸ‘‹"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["graphql", "typescript"]
published: false
---

# ç’°å¢ƒæ§‹ç¯‰

ä½œæ¥­ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½œæˆã—ã€VSCodeã‚’é–‹ãã€‚
```sh
mkdir graphql-server-demo
code graphql-server-demo
```

GraphQLã‚µãƒ¼ãƒãƒ¼ã‚’ç«‹ã¦ã‚‹ã®ã«å¿…è¦ãªãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’è¿½åŠ ã™ã‚‹ã€‚
```sh
npm install @apollo/server graphql
```

```sh
npm install ts-node
npm install --save-dev typescript @type/node nodemon
npx tsc --init
```

ts-nodeã®è¨­å®šã‚’å¤‰æ›´ã™ã‚‹
```json:tsconfig.json
{
  "compilerOptions": {
    "rootDirs": ["src"],
    "outDir": "dist",
    "lib": ["es2020"],
    "target": "es2020",
    "module": "esnext",
    "moduleResolution": "node",
    "esModuleInterop": true,
    "types": ["node"]
  }
}
```

```json:package.json
{
  "type": "module",
  "scripts": {
    "compile": "tsc",
    "start": "npm run compile && node ./dist/index.js",
    "start:dev": "nodemon --exec node --loader ts-node/esm --no-warnings ./index.ts"
  },
  "dependencies": {
    "@apollo/server": "^4.11.0",
    "graphql": "^16.9.0",
    "nodemon": "^3.1.7",
    "ts-node": "^10.9.2"
  },
  "devDependencies": {
    "@types/node": "^22.7.4",
    "typescript": "^5.6.2"
  }
}
```

# GraphqLã‚µãƒ¼ãƒãƒ¼
```ts:index.ts
const server = new ApolloServer({
    typeDefs: null
});

const { url } = await startStandaloneServer(server, {
    listen: { port: 4000 },
});

console.log(`ğŸš€  Server ready at: ${url}`);
```

ä»¥ä¸‹ã®ã‚¨ãƒ©ãƒ¼ãŒå‡ºã‚‹ã€‚
```sh
Error: Query root type must be provided.
```

# ãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‰ã—ãŸå€¤ã‚’è¿”ã™GraphQL APIã‚’å®Ÿè£…
GraphQLã§ã¯ã‚¹ã‚­ãƒ¼ãƒã¨ãƒªã‚¾ãƒ«ãƒãŒé‡è¦ãªæ§‹æˆè¦ç´ 
ã‚¹ã‚­ãƒ¼ãƒã§å‹å®šç¾©
ãƒªã‚¾ãƒ«ãƒã§ã‚¹ã‚­ãƒ¼ãƒã®å‹ã«å¾“ã£ãŸå…·ä½“çš„ãªå‡¦ç†
```ts:index.ts
const typeDefs = `#graphql
    type Query {
        Greeting: String
    }
`;

const server = new ApolloServer({
    typeDefs
});
```

http://localhost:4000/ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã€‚
ã‚µã‚¤ãƒ‰ãƒãƒ¼ã®Documentationã‚¿ãƒ–ã§Queryã«GreetingãŒå­˜åœ¨ã™ã‚‹ã“ã¨ã‚’ç¢ºèªã€‚
operationã«ä»¥ä¸‹ã‚’å…¥åŠ›ã—å®Ÿè¡Œãƒœã‚¿ãƒ³ã‚’æŠ¼ä¸‹ã™ã‚‹ã€‚
```gql
query Greet {
  Greeting
}
```

ç©ºã®ãƒ‡ãƒ¼ã‚¿ãŒè¿”ã£ã¦ãã‚‹ã€‚
```json
{
  "data": {
    "Greeting": null
  }
}
```

ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã—ã¦ã‚ã’ã‚‹ãŸã‚ã«ã¯resolverã‚’å®šç¾©ã—ã¦ã‚ã’ã€ã•ã‚‰ã«ãã‚Œã‚’ã‚¹ã‚­ãƒ¼ãƒå®šç¾©ã¨ã¨ã‚‚ã«ApolloServerã«æ¸¡ã—ã¦ã‚ã’ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
https://www.apollographql.com/docs/apollo-server/data/resolvers
https://www.apollographql.com/docs/apollo-server/data/resolvers#passing-resolvers-to-apollo-server
ã¾ãšã¯Greetingã‚¯ã‚¨ãƒªã®æˆ»ã‚Šå€¤ã‚’å›ºå®šå€¤ã¨ã—ã¦è¿”ã™ã€‚

```ts:index.ts
const typeDefs = `#graphql
    type Query {
        Greeting: String
    }
`;

const resolvers = {
    Query: {
        Greeting: () => 'Hello world!'
    },
};

const server = new ApolloServer({
    typeDefs,
    resolvers
});
```

å†åº¦å®Ÿè¡Œãƒœã‚¿ãƒ³ã‚’æŠ¼ä¸‹ã™ã‚‹ã¨ä»¥ä¸‹ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒå¾—ã‚‰ã‚Œã‚‹ã€‚
```json
{
  "data": {
    "Greeting": "Hello world!"
  }
}
```

ã¡ãªã¿ã«æœ€åˆã¯å‹å®šç¾©ã ã‘æŒ‡å®šã—ã¦ãƒªã‚¾ãƒ«ãƒãƒ¼ã‚’å®šç¾©ã—ã¦ã„ãªã‹ã£ãŸãŒã‚¨ãƒ©ãƒ¼ãŒå‡ºãªã‹ã£ãŸã€‚
Queryã®å‹å®šç¾©ã§Greetingã‚’æŒ‡å®šã—ãŸãŒã€resolverã§ã¯Greetinã¨ç•°ãªã‚‹å‘½åã‚’ã™ã‚‹ã¨ã©ã†ãªã‚‹ã‹ã€‚
```ts:index.ts
const resolvers = {
    Query: {
        Greetin: () => 'Hello world!'
    },
};
```

ã‚¨ãƒ©ãƒ¼ãŒã§ã‚‹ã€‚
å‹å®šç¾©ã«å¯¾å¿œã™ã‚‹ãƒªã‚¾ãƒ«ãƒãƒ¼ã¯ãªãã¦ã‚‚ã‚¨ãƒ©ãƒ¼ãŒå‡ºãªã„ãŒã€ãƒªã‚¾ãƒ«ãƒãƒ¼ã«å¯¾å¿œã™ã‚‹å‹å®šç¾©ã¯å¿…é ˆã§ã‚ã‚‹ã“ã¨ãŒã‚ã‹ã‚‹ã€‚
```sh
Query.Greetin defined in resolvers, but not in schema
```

ä»Šå›å›ºå®šå€¤ã¨ã—ãŸæˆ»ã‚Šå€¤ã‚’å¤‰æ•°ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚„3rd Party APIã‹ã‚‰å–ã‚Šå‡ºã™ã“ã¨ã‚‚ã§ããã†ã€‚
æ¬¡ã¯å¤‰æ•°ã‹ã‚‰å€¤ã‚’å–ã‚Šå‡ºã—ã¦ã¿ã‚‹ã€‚

# é…åˆ—ã‚’è¿”ã™Query APIã‚’å®Ÿè£…

```ts:index.ts
const typeDefs = `#graphql
    type Book {
        title: String
        author: String
    }
    
    type Query {
        allBooks: [Book]!
    }
`;

const books = [
    {
      title: 'The Awakening',
      author: 'Kate Chopin',
    },
  ];

const resolvers = {
    Query: {
        allBooks: () => books,
    },
};
```

Operationã‚’æ›¸ãæ›ãˆã¦å®Ÿè¡Œãƒœã‚¿ãƒ³ã‚’æŠ¼ä¸‹ã™ã‚‹ã¨æ›¸ç±ã‚’1ä»¶æŒã¤é…åˆ—ãŒå–ã‚Œã‚‹ã€‚
```gql
query AllBooks {
  allBooks {
    title
    author
  }
}
```

æ›¸ç±ã‚’2å†Šå«ã‚ã¦ã€å†åº¦å®Ÿè¡Œãƒœã‚¿ãƒ³ã‚’æŠ¼ä¸‹ã™ã‚‹ã¨ä¸¡æ–¹ã¨ã‚‚ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã«å«ã¾ã‚Œã¦ã„ã‚‹ã€‚
```ts:index.ts
const books = [
    {
      title: 'The Awakening',
      author: 'Kate Chopin',
    },
    {
      title: 'City of Glass',
      author: 'Paul Auster',
    }
  ];
```

# å‹å®šç¾©å†…ã§åˆ¥ã®å‹å®šç¾©ã‚’åˆ©ç”¨

```ts:index.ts
const typeDefs = `#graphql
    type Book {
        title: String
        author: Author
    }

    type Author {
        name: String
        books: [Book]
    }
    
    type Query {
        allBooks: [Book]!
    }
`;

const books = [
    {
      title: 'The Awakening',
      author: {
        name: 'Kate Chopin',
        books: []
      },
    },
    {
      title: 'City of Glass',
      author: {
        name: 'Paul Auster',
        books: []
      },
    }
  ];
```

operationã‚’æ›´æ–°ã™ã‚‹ã€‚
```gql
query AllBooks {
  allBooks {
    title
    author {
      name
      books {
        title
      }
    }
  }
}
```

ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã«ã¯æ›¸ç±ã®ã¿ãªã‚‰ãšè‘—è€…ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚‚å–ã‚Œã¦ã„ã‚‹ã€‚
```json
{
  "data": {
    "allBooks": [
      {
        "title": "The Awakening",
        "author": {
          "name": "Kate Chopin",
          "books": []
        }
      },
      {
        "title": "City of Glass",
        "author": {
          "name": "Paul Auster",
          "books": []
        }
      }
    ]
  }
}
```

ãƒ–ãƒ©ã‚¦ã‚¶é–‹ç™ºè€…ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã®consoleã‚¿ãƒ–ã‚’é–‹ãã€ä»¥ä¸‹ã‚’å…¥åŠ›
```js
await fetch('http://localhost:4000/', {method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          query: `query{
                      allBooks{
                          title
                        }
                    }`,
        }),
      }));
```

ä»¥ä¸‹ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒè¡¨ç¤ºã•ã‚Œã€ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒ¼ãƒ‰ãŒ200ã§ãƒªã‚¯ã‚¨ã‚¹ãƒˆã«æˆåŠŸã—ãŸã“ã¨ãŒã‚ã‹ã‚‹ã€‚
```json
Response {type: 'basic', url: 'http://localhost:4000/', redirected: false, status: 200, ok: true, â€¦}
```

ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®ä¸­èº«ã‚’Responseã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®jsonãƒ¡ã‚½ãƒƒãƒ‰ã§ç¢ºèªã™ã‚‹
```js
await (await fetch('http://localhost:4000/', {method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          query: `query{
                      allBooks{
                          title
                        }
                    }`,
        }),
      })).json();
```

å…ˆã»ã©ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–ã‚Šå‡ºã™ã“ã¨ãŒã§ããŸã€‚
GraphQLã‚µãƒ¼ãƒãƒ¼ã«ã‚¯ã‚¨ãƒªã—ãŸã„ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯REST APIã¨åŒã˜ã‚ˆã†ã«fetché–¢æ•°ã‚’ç”¨ã„ã‚‹ã ã‘ã§è‰¯ã„ã“ã¨ãŒã‚ã‹ã‚‹ã€‚
ãŸã ã—ã€ç¬¬ä¸€å¼•æ•°ã®URLã«ã¯å¸¸ã«ãƒ«ãƒ¼ãƒˆã®URLã‚’æ¸¡ã—ã€ãã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒœãƒ‡ã‚£ã«ã¯jsonå½¢å¼ã§ã‚¯ã‚¨ãƒªãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’è¨˜è¼‰ã™ã‚‹ã€‚
ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒœãƒ‡ã‚£ã«å¿…è¦ãªãƒ‡ãƒ¼ã‚¿ã‚’æŒ‡å®šã™ã‚‹ãŸã‚ã«ã€HTTPãƒ¡ã‚½ãƒƒãƒ‰ã¯GETã§ã¯ã„ã‘ãªã„ã€POSTã‚’æŒ‡å®šã™ã‚‹ã€‚
```json
{
    "data": {
        "allBooks": [
            {
                "title": "The Awakening"
            },
            {
                "title": "City of Glass"
            }
        ]
    }
}
```

# å¼•æ•°ã‚’å–ã‚‹Query APIã‚’å®Ÿè£…

Bookã‚¯ã‚¨ãƒªã‚’å‹å®šç¾©ã«è¿½åŠ ã™ã‚‹ã€‚
```ts:index.ts
const typeDefs = `#graphql
    ...
    
    type Query {
        Book(title: String!): Book
        allBooks: [Book]!
    }
`;
```

å¼•æ•°titleã‚’ç”¨ã„ã¦å¯¾è±¡ã®æ›¸ç±ã‚’å–ã‚‹ã€‚
```ts:index.ts
const resolvers = {
    Query: {
        allBooks: () => books,
        Book: (_, { title }) => books.find(book => title === book.title) 
    },
};
```

ä»¥ä¸‹ã®ã‚ˆã†ã«å¼•æ•°ã‚’å›ºå®šã—ã¦Operationã‚’è¨­å®šã™ã‚‹ã€‚
```gql
query Book {
  Book(title: "The Awakening") {
    title
  }
}
```

ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒå–ã‚Œã¦ã„ã‚‹ã€‚
```json
{
  "data": {
    "Book": {
      "title": "The Awakening"
    }
  }
}
```

å¼•æ•°ã‚’æ¸¡ã›ã‚‹ã‚ˆã†ã«ã™ã‚‹ã€‚
```gql
query Greet($title: String!) {
  Book(title: $title) {
    title
  }
}
```

Variablesã«titleã‚’å«ã‚ã‚‹ã€‚
```json
{
  "title": "The Awakening",
}
```

å…ˆã»ã©ã¨åŒã˜ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒå–ã‚Œã¦ã„ã‚‹ã€‚
```json
{
  "data": {
    "Book": {
      "title": "The Awakening"
    }
  }
}
```

å­˜åœ¨ã—ãªã„ã‚¿ã‚¤ãƒˆãƒ«ã‚’å¼•æ•°ã«æ¸¡ã—ã¦ã‚‚ã‚¨ãƒ©ãƒ¼ã¯å‡ºãªã„
```json
{
  "title": "The Asleeping",
}
```

```json
{
  "data": {
    "Book": null
  }
}
```

è¤‡æ•°ã‚¯ã‚¨ãƒªã‚’åŒæ™‚ã«å«ã‚ã‚‹ã“ã¨ãŒã§ãã‚‹

```gql
query Greet($title: String!) {
  allBooks {
    title
  }
  
  Book(title: $title) {
    title
  }
}
```

```json
{
  "title": "The Awakening",
}
```

```json
{
  "data": {
    "allBooks": [
      {
        "title": "The Awakening"
      },
      {
        "title": "City of Glass"
      }
    ],
    "Book": {
      "title": "The Awakening"
    }
  }
}
```

# Mutation APIã‚’å®Ÿè£…

ä½œæˆãƒŸãƒ¥ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè£…ã€‚
```ts:index.ts
const typeDefs = `#graphql
    type Book {
        title: String
        author: Author
    }

    type Author {
        name: String
        books: [Book]
    }
    
    type Query {
        Book(title: String!): Book
        allBooks: [Book]!
    }

    type Mutation {
        createBook(title: String!, authorName: String!): Book!
    }
`;
```

åŒæœŸçš„ã«é…åˆ—booksã«æ–°è¦æ›¸ç±ã‚’è©°ã‚ã‚‹ã€‚
```ts:index.ts
const resolvers = {
    Query: {
        allBooks: () => books,
        Book: (_, { title }) => books.find(book => title === book.title) 
    },
    Mutation: {
        createBook: (_, { title, authorName }) => books.push({title, author: {name: authorName, books: []}});
    }
};
```

operationã«ä»¥ä¸‹ã‚’è¨­å®šã—å®Ÿè¡Œã€‚
```gql
mutation CreateBook($title: String!, $authorName: String!) {
  createBook(title: $title, authorName: $authorName) {
    title
    author {
      name
    }
  }
}
```

```json
{
  "title": "Hello",
  "authorName": "Jim",
}
```

ã‚¨ãƒ©ãƒ¼ãŒè¿”ã£ã¦ãã‚‹ã€‚
```json
{
  "errors": [
    {
      "message": "Cannot return null for non-nullable field Mutation.createBook.",
      "locations": [
        {
          "line": 3,
          "column": 3
        }
      ],
      "path": [
        "createBook"
      ],
      ...
    }
  ]
}
```

ä½œæˆã—ãŸå¾Œã«é…åˆ—ã‹ã‚‰ä½œæˆã—ãŸæ›¸ç±ã‚’å–ã‚Šã«è¡Œãã€‚
å…ˆã»ã©æ–°è¦æ›¸ç±ãŒãƒ¡ãƒ¢ãƒªä¸Šã®é…åˆ—ã«è©°ã‚ã¦ã—ã¾ã£ãŸã®ã§ã€ã‚µãƒ¼ãƒãƒ¼ã‚’ç«‹ã¡ä¸Šã’ç›´ã™ã€‚
```ts:index.ts
const resolvers = {
    Query: {
        allBooks: () => books,
        Book: (_, { title }) => books.find(book => title === book.title) 
    },
    Mutation: {
        createBook: (_, { title, authorName }) => {
            books.push({title, author: {name: authorName, books: []}});
            return books.find(books => books.title === title)
        }
    }
};
```

å€¤ãŒå–ã‚Œã‚‹ã‚ˆã†ã«ãªã£ãŸã€‚
```json
{
  "data": {
    "createBook": {
      "title": "Hello",
      "author": "Jim"
    }
  }
}
```

å…¨ä»¶å–å¾—ã§å…ˆã»ã©è©°ã‚ãŸæ›¸ç±ãŒå–ã‚Œã‚‹ã‚ˆã†ã«ãªã£ãŸã€‚
```gql
query allBooks {
  allBooks {
    title
    author {
      name
    }
  }
}
```

```json
{
  "data": {
    "allBooks": [
      {
        "title": "The Awakening",
        "author": {
          "name": "Kate Chopin"
        }
      },
      {
        "title": "City of Glass",
        "author": {
          "name": "Paul Auster"
        }
      },
      {
        "title": "Hello",
        "author": {
          "name": "Jim"
        }
      }
    ]
  }
}
```

# CRUDã‚’å…¨ã¦å®Ÿè£…
```ts:index.ts
    type Mutation {
        createBook(title: String!, authorName: String!): Book!
        updateBook(title: String!, authorName: String!): Book!
    }
```

```ts:index.ts
const resolvers = {
    Query: {
        allBooks: () => books,
        Book: (_, { title }) => books.find(book => title === book.title) 
    },
    Mutation: {
        createBook: (_, { title, authorName }) => {
            books.push({title, author: {name: authorName, books: []}});
            return books.find(books => books.title === title)
        },
        updateBook: (_, { title, authorName }) => {
            const targetBook = books.find(book => book.title === title);
            if (!targetBook) throw new Error('book not found');
            targetBook.author.name = authorName;
            return targetBook;
        }
    }
};
```

```gql
mutation UpdateBook($title: String!, $authorName: String!) {
  updateBook(title: $title, authorName: $authorName) {
    title
    author {
      name
    }
  }
}
```

```json
{
  "title": "Hello",
  "authorName": "Jimmy",
}
```

```json
{
  "data": {
    "updateBook": {
      "title": "Hello",
      "author": {
        "name": "Jimmy"
      }
    }
  }
}
```

```json
{
  "data": {
    "allBooks": [
      {
        "title": "The Awakening",
        "author": {
          "name": "Kate Chopin"
        }
      },
      {
        "title": "City of Glass",
        "author": {
          "name": "Paul Auster"
        }
      },
      {
        "title": "Hello",
        "author": {
          "name": "Jimmy"
        }
      }
    ]
  }
}
```

```json
{
  "title": "Hell",
  "authorName": "Jimmy",
}
```

```json
{
  "errors": [
    {
      "message": "book not found",
      "locations": [
        {
          "line": 20,
          "column": 3
        }
      ],
      "path": [
        "updateBook"
      ],
      ...
    }
  ]
}
```

```ts:index.ts
        createBook: (_, { title, authorName }) => {
            const isRegistered = !!books.findIndex(book => book.title === title);
            if (isRegistered) throw new Error('the book is already registered');
            books.push({title, author: {name: authorName, books: []}});
            return books.find(books => books.title === title)
        },
```

```json
{
  "errors": [
    {
      "message": "the book is already registered",
      "locations": [
        {
          "line": 11,
          "column": 3
        }
      ],
      "path": [
        "createBook"
      ],
      ...
    }
  ]
}
```

```ts:index.ts
    type Mutation {
        createBook(title: String!, authorName: String!): Book!
        updateBook(title: String!, authorName: String!): Book!
        deleteBook(title: String!): Book!
    }
```

```ts:index.ts
    Mutation: {
        createBook: (_, { title, authorName }) => {
            const isRegistered = !!books.find(book => book.title === title);
            if (isRegistered) throw new Error('the book is already registered');
            books.push({title, author: {name: authorName, books: []}});
            return books.find(books => books.title === title)
        },
        updateBook: (_, { title, authorName }) => {
            const targetBook = books.find(book => book.title === title);
            if (!targetBook) throw new Error('book not found');
            targetBook.author.name = authorName;
            return targetBook;
        },
        deleteBook: (_, { title }) => {
            const index = books.findIndex(book => book.title === title);
            if (index === -1) throw new Error('book not found');
            return books.splice(index, 1).at(0)
        }
    }
```

```gql
mutation DeleteBook($title: String!) {
  deleteBook(title: $title) {
    title
    author {
      name
    }
  }
}
```

```json
{
  "title": "Hello",
}
```

```json
{
  "data": {
    "deleteBook": {
      "title": "Hello",
      "author": {
        "name": "Jimmy"
      }
    }
  }
}
```

```json
{
  "data": {
    "allBooks": [
      {
        "title": "The Awakening",
        "author": {
          "name": "Kate Chopin"
        }
      },
      {
        "title": "City of Glass",
        "author": {
          "name": "Paul Auster"
        }
      }
    ]
  }
}
```

# REST APIã‚’ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹ã«åˆ©ç”¨

ApolloServerã®data source APIã‚’ç”¨ã„ã¦REST APIã‚„DBãªã©ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹ã‚’GraphQL APIã«ç¹‹ãã“ã‚€ã“ã¨ãŒã§ãã‚‹
REST APIã®ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹ã‚’ç”¨ã„ã‚‹ãŸã‚ã«ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
```sh
npm install @apollo/datasource-rest
```

ãƒ©ã‚¤ãƒ–ãƒ©ãƒª@apollo/datasource-restãŒæä¾›ã™ã‚‹RESTDataSourceã‚¯ãƒ©ã‚¹ã¯REST API ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ•ã‚§ãƒƒãƒã—ã€ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’ã‚¤ãƒ³ãƒ¡ãƒ¢ãƒªã«ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã™ã‚‹æ©Ÿèƒ½ã‚’æä¾›ã—ã¦ã„ã‚‹ã€‚
getãƒ¡ã‚½ãƒƒãƒ‰ã¯GET HTTPãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰

REST APIã¯ä»¥ä¸‹ã‹ã‚‰è¦‹ã¤ã‘ãŸã€‚
https://www.postman.com/science-geoscientist-92587966/test/request/5m7rzhl/api-list-of-books?tab=overview

```ts:dataSources/rest.ts
import { RESTDataSource } from '@apollo/datasource-rest';

export class AllBooksAPI extends RESTDataSource {
  constructor() {
    super();
    this.baseURL = 'https://simple-books-api.glitch.me/';
  }

  async queryAllBooks() {
    const response = await this.get('books', {params: {type: "non-fiction"}});
    return Array.isArray(response) ? response.map(line => this.convertIntoBookType(line)) : []
  }

  private convertIntoBookType(book: any) {
    return {
        title: book.name, author: {
        name: book.author,
        books: []
    }}
  }
}
```

Apollo Serverã¯æ¯åº¦ã®Operationã§contextåˆæœŸåŒ–é–¢æ•°ã‚’å‘¼ã³å‡ºã™(operationã¨ã¯ï¼Ÿ)
AllBooksAPIãŒæ¯åº¦åˆæœŸåŒ–ã•ã‚Œã‚‹
```ts:index.ts
const {url} = await startStandaloneServer(server, {
    listen: {port: 4000},
    context: async () => {
        return {
            dataSources: {
                allBooksApi: new AllBooksAPI()
            }
        }
    }
})
```

# GraphQLã‚¹ã‚­ãƒ¼ãƒã‚’å¤–éƒ¨ãƒ•ã‚¡ã‚¤ãƒ«åŒ–
https://zenn.dev/eringiv3/books/a85174531fd56a/viewer/a8fab6

```ts:index.ts
import { GraphQLFileLoader } from '@graphql-tools/graphql-file-loader';
import { loadSchemaSync } from '@graphql-tools/load';
import { addResolversToSchema } from '@graphql-tools/schema';
import { ApolloServer } from "@apollo/server";
import {startStandaloneServer} from '@apollo/server/standalone'
import { AllBooksAPI } from "./dataSources/rest.js";
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url); // get the resolved path to the file
const __dirname = dirname(__filename);

const schema = loadSchemaSync(join(__dirname, '../schema.graphql'), {
    loaders: [new GraphQLFileLoader()],
  });

...

const schemaWithResolvers = addResolversToSchema({ schema, resolvers });
const server = new ApolloServer({ schema: schemaWithResolvers });
```

# GraphQLã®ã‚¹ã‚­ãƒ¼ãƒå®šç¾©ã‹ã‚‰TypeScriptã®å‹å®šç¾©ã‚’è‡ªå‹•ç”Ÿæˆ
https://zenn.dev/eringiv3/books/a85174531fd56a/viewer/382755

```sh
npm install @graphql-codegen/cli @graphql-codegen/typescript @graphql-codegen/typescript-resolvers
```

```json
"codegen": "graphql-codegen --config codegen.yml"
```

```yml:codegen.yml
overwrite: true
generates:
  ./src/types/generated/graphql.ts:
    schema: schema.graphql
    config:
      useIndexSignature: true
      # ãƒªã‚¾ãƒ«ãƒãƒ¼ã®ãŸã‚ã®Contextã®å‹ã‚’src/types/context.d.tsã‹ã‚‰èª­ã¿è¾¼ã‚€
      contextType: ../context#Context
    plugins:
      - typescript
      - typescript-resolvers
```

```sh
npm run codegen
```
# parentã‚’åˆ©ç”¨
https://reffect.co.jp/html/graphql#parent

# DataLoaderã‚’ä½¿ã†
https://www.apollographql.com/docs/apollo-server/data/fetching-data#batching-and-caching

# Prismaç§»è¡Œ
https://zenn.dev/eringiv3/books/a85174531fd56a/viewer/9d538f

```yml:docker-compose.yml
version: '3.8'
services:
  postgres:
    image: postgres:10.3
    restart: always
    environment:
      - POSTGRES_USER=postgresuser
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres:/var/lib/postgresql/data
    ports:
      - '5432:5432'
volumes:
  postgres:
```

```sh
docker-compose up
npm install prisma
npx prisma init
```

.envã«DBã®URL
```:.env
DATABASE_URL=postgresql://postgresuser:password@localhost:5432
```

```prisma:schema.prisma
enum SalesStatus {
  SOLD
  IN_SALE
}

model Book {
  id  Int @id @default(autoincrement())
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  title String  @db.VarChar(255)
  description String?  @db.VarChar(255)
  status SalesStatus @default(IN_SALE)
  author Author @relation(fields: [authorId], references: [id])
  authorId Int
}

model Author {
  id  Int @id @default(autoincrement())
  name  String  @db.VarChar(255)
  books Book[]
}
```

```sh
prisma migrate dev --name init 
```

```sh
npm install @prisma/client
```

```ts:seed.ts
import { PrismaClient, Book, Author } from "@prisma/client";

const prisma = new PrismaClient();

const main = async () => {
    const authors: Author[] = await createAuthors();
    const books = await Promise.all(authors.map(author => createBooks(author)))

    console.log({
        authors,
        books
    })
}

const createAuthors = async () => {
    const promises = [...Array(5)].map((_, i) => {
        const authorId = i
        return prisma.author.upsert({
            where: {id: authorId},
            update: {},
            create: {
                id: authorId,
                name: `Jim No.${authorId}`
            }
        })
    })

    return await Promise.all(promises);
}

const createBooks = async (author: Author) => {
    const promises = [...Array(3)].map((_, i) => {
        const bookId = i;
        return prisma.book.upsert({
            where: { id: bookId },
            update: {},
            create: {
                title: `Book No.${bookId} By ${author.name}`,
                authorId: author.id
            }
        })
    })

    return await Promise.all(promises)
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
```

https://stackoverflow.com/questions/62096269/unknown-file-extension-ts-for-a-typescript-file
```sh
node --loader ts-node/esm prisma/seed.ts
```

ã‚·ãƒ¼ãƒ‰ãŒç”Ÿæˆã•ã‚Œã‚‹ã€‚
```sh
{
  authors: [
    { id: 0, name: 'Jim No.0' },
    { id: 1, name: 'Jim No.1' },
    { id: 2, name: 'Jim No.2' },
    { id: 3, name: 'Jim No.3' },
    { id: 4, name: 'Jim No.4' }
  ],
  books: [
    [ [Object], [Object], [Object] ],
    [ [Object], [Object], [Object] ],
    [ [Object], [Object], [Object] ],
    [ [Object], [Object], [Object] ],
    [ [Object], [Object], [Object] ]
  ]
}
```

Prismaã«ä»˜å±ã—ã¦ã„ã‚‹GUIãƒ„ãƒ¼ãƒ«ã§ã‚·ãƒ¼ãƒ‰ãŒè¿½åŠ ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèªã§ãã‚‹ã€‚
```sh
npx prisma studio
```

prismaç§»è¡Œã€‚
å¤‰æ•°booksã‚’å‰Šé™¤ã™ã‚‹ã€‚
```ts
import { PrismaClient } from '@prisma/client';
const prisma = new PrismaClient();
...
const resolvers = {
    Query: {
        allBooks: async () => {
          return await prisma.book.findMany()
        },
        Book: async (_, { id }: BookQueryArgs) => {
          return await prisma.book.findFirst({where: { id }, include: {author: true}})
        }
    },
    Mutation: {
        createBook: async (_, { title, authorId }: CreateBookMutationArgs) => {
            return await prisma.book.create({
              data: {
                title,
                authorId
              },
              include: {
                author: true
              }
            })
        },
        updateBook: async (_, { id, title, description }) => {
            return await prisma.book.update({
              where: { id },
              data: {
                title,
                description
              },
              include: {
                author: true
              }
            })
        },
        deleteBook: async (_, { id }) => {
            return await prisma.book.delete({
              where: { id },
              include: {
                author: true
              }
            })
        },
        addRestBook: async (_a, _b, { dataSources }) => {
            const queriedBooks = await dataSources.allBooksApi.queryAllBooks();
            return prisma.book.createManyAndReturn({
              data: queriedBooks.map(book => ({ title: book.title, authorId: 0 })),
              include: { author: true },
              skipDuplicates: true
            })
        },
    }
};
```

# input typeå°å…¥

```gql
input BookQueryArgs {
    id: Int!
}

type Query {
    Book(args: BookQueryArgs!): Book
    allBooks: [Book]!
}
```

```sh
npm run codegen
```

```ts:index.ts
import { BookQueryArgs, CreateBookMutationArgs } from './types/generated/graphql.js';
...
    Query: {
        allBooks: async () => {
          return await prisma.book.findMany()
        },
        Book: async (_, { id }: BookQueryArgs) => {
          return await prisma.book.findFirst({where: { id }, include: {author: true}})
        }
    },
```

```json
{
  "args": {
    "id": 0
  }
}
```

```json
{
  "data": {
    "Book": {
      "title": "Book No.12 By Jim No.1",
      "author": {
        "name": "Jim No.1"
      }
    }
  }
}
```

```gql
input CreateBookMutationArgs {
    title: String!
    authorId: Int!
}

type Mutation {
    createBook(args: CreateBookMutationArgs!): Book!
    updateBook(id: Int!, title: String!, description: String!): Book!
    deleteBook(id: Int!): Book!
    addRestBook: [Book]!
}
```

```ts:index.ts
        createBook: async (_, { args: { title, authorId } }: { args: CreateBookMutationArgs }) => {
            return await prisma.book.create({
              data: {
                title,
                authorId
              },
              include: {
                author: true
              }
            })
        },
```

```json
{
  "args": {
    "title": "hoge",
    "authorId": 2
  }
}
```

```json
{
  "data": {
    "createBook": {
      "title": "hoge",
      "author": {
        "name": "Jim No.2"
      }
    }
  }
}
```

# èªè¨¼
https://zenn.dev/eringiv3/books/a85174531fd56a/viewer/9d538f

# Fluent APIåˆ©ç”¨
https://zenn.dev/nyatinte/articles/48f32a4d4a2762

# ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³åˆ©ç”¨
https://zenn.dev/cloudbase/articles/65b9f6e4f9ae05#prisma%E3%81%AE%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6

# Prismaãƒ†ã‚¹ãƒˆ
https://www.prisma.io/docs/orm/prisma-client/testing/unit-testing
https://dev.classmethod.jp/articles/prisma-jest-isolated-transaction/

# Prismaã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£
https://zenn.dev/cloudbase/articles/65b9f6e4f9ae05#%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3

# Schema Firstã¨Code First

# ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã‚¢ãƒ—ãƒªã¨ç¹‹ãã“ã‚€

# expressç§»è¡Œ

# NestJSç§»è¡Œ

å‚è€ƒæ–‡çŒ®
https://apollographql-jp.com/tutorial/queries/
