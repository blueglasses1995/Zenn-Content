---
title: "Nest ApolloServer Prisma"
emoji: "ğŸŒŸ"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: []
published: false
---

```sh
npm i -g @nestjs/cli
nest new nest-apollo
code nest-apollo
```

```sh
npm i @nestjs/graphql @nestjs/apollo @apollo/server graphql
```

```ts:app.module.ts
import { Module } from '@nestjs/common';
import { GraphQLModule } from '@nestjs/graphql';
import { ApolloDriver, ApolloDriverConfig } from '@nestjs/apollo';

@Module({
  imports: [
    GraphQLModule.forRoot<ApolloDriverConfig>({
      driver: ApolloDriver,
    }),
  ],
})
export class AppModule {}
```

ã‚µãƒ¼ãƒãƒ¼ã‚’ç«‹ã¡ä¸Šã’ã‚‹ã¨ã€`Query root type must be provided`ã¨ã®ã‚¨ãƒ©ãƒ¼ãŒå‡ºã‚‹ã€‚
```sh
npm run start:dev
```

ã‚¹ã‚­ãƒ¼ãƒãƒ•ã‚¡ãƒ¼ã‚¹ãƒˆã§é–‹ç™ºã™ã‚‹ã“ã¨ã¨ã—ã€GraphQL SDLã‚¹ã‚­ãƒ¼ãƒå®šç¾©ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ã‚’æŒ‡å®šã™ã‚‹ã€‚
ã¾ã ã‚¹ã‚­ãƒ¼ãƒå®šç¾©ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã—ã¦ã„ãªã„ãŸã‚ã€`No type definitions were found with the specified file name patterns`ã¨ã‚¨ãƒ©ãƒ¼ãŒå‡ºã‚‹ã€‚

```ts:app.module.ts
imports: [
    GraphQLModule.forRoot<ApolloDriverConfig>({
      driver: ApolloDriver,
      typePaths: ['./**/*.graphql'],
    }),
  ],
```

é–‹ç™ºæ™‚ã«ã¯ã‚¹ã‚­ãƒ¼ãƒå®šç¾©ã«å¯¾å¿œã™ã‚‹TypeScriptå‹ãŒæ¬²ã—ã„ã€‚
ä¸€èˆ¬ã«ã¯codegenã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ãŒå¤šã„ã€‚
`@nestjs/graphql`ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯ASTã‚’ç”¨ã„ã¦ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’èµ·å‹•ã™ã‚‹ãŸã³ã«ã‚¹ã‚­ãƒ¼ãƒå®šç¾©ã‹ã‚‰TypeScriptå‹ã‚’è‡ªå‹•ç”Ÿæˆã™ã‚‹ã€‚
ç”Ÿæˆã•ã‚Œã‚‹TypeScriptå‹ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã ãŒã€`outputAs`ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã§ã‚¯ãƒ©ã‚¹ã«å¤‰æ›´ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚

```ts:app.module.ts
  imports: [
    GraphQLModule.forRoot<ApolloDriverConfig>({
      driver: ApolloDriver,
      typePaths: ['./**/*.graphql'],
      definitions: {
        path: join(process.cwd(), 'src/graphql.ts'),
        outputAs: 'class',
      },
    }),
  ],
```

ã‚¹ã‚­ãƒ¼ãƒãƒ•ã‚¡ãƒ¼ã‚¹ãƒˆã®å ´åˆã€TSã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼APIãƒ©ãƒƒãƒ‘ãƒ¼ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã™ã‚‹ã€‚
```sh
npm i ts-morph
```

```ts:Author/author.graphql
type Author {
  id: ID!
  firstName: String!
  lastName: String!
}
```

```ts:query.graphql
type Query {
  Author(id: ID!): Author
}
```

ã‚µãƒ¼ãƒãƒ¼ã‚’ç«‹ã¡ä¸Šã’ç›´ã™ã¨ã€ã‚¨ãƒ©ãƒ¼ãŒå‡ºãªããªã‚‹ã€‚
http://localhost:3000/graphqlã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã¨graphql playgroundã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã€‚
ã‚¯ã‚¨ãƒªã‚’ä»¥ä¸‹ã®ã‚ˆã†ã«è¨­å®šã—å®Ÿè¡Œã™ã‚‹ã¨jsonãŒå¾—ã‚‰ã‚Œã‚‹ã€‚

```gql
query fetch {
  Author(id: "1") {
    id
    firstName
  }
}
```

```json
{
  "data": {
    "Author": null
  }
}
```

ä¸€èˆ¬çš„ã«ã¯GraphQLã®ã‚¹ã‚­ãƒ¼ãƒå®šç¾©ã®type Queryã«å¯¾å¿œã™ã‚‹ãƒªã‚¾ãƒ«ãƒãƒ¼ã®ãƒãƒƒãƒ—ã‚’æ‰‹å‹•ã§è¨­å®šã™ã‚‹ã€‚
ã—ã‹ã—ã€`@nestjs/graphql`ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’ç”¨ã„ã‚‹ã¨`Resolver`ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ãƒ¼ã«ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’æ¸¡ã™ã“ã¨ã§ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãŒè‡ªå‹•ã§ãƒªã‚¾ãƒ«ãƒãƒ¼ãƒãƒƒãƒ—ã‚’ç”Ÿæˆã—ã¦ãã‚Œã‚‹ã€‚

ã¾ãšãƒªã‚¾ãƒ«ãƒãƒ¼ç”¨ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã™ã‚‹ã€‚

```sh
nest g r Author
```

ãƒªã‚¾ãƒ«ãƒãƒ¼ã‚’å®Ÿè£…ã™ã‚‹ã€‚
`Query`ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ãƒ¼ã¯`@nestjs/graphql`ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‹ã‚‰ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ã€‚
ã‚¹ã‚­ãƒ¼ãƒå®šç¾©ã‹ã‚‰TSå‹ãŒè‡ªå‹•ç”Ÿæˆã•ã‚Œã¦ã„ã‚‹ã®ã§ã€Authorå‹ã‚’åˆ©ç”¨ã™ã‚‹ã€‚

```ts:Author/author.resolver.ts
@Resolver()
export class AuthorResolver {
  @Query()
  Author(@Args('id') id: string): Author {
    return { id, firstName: 'John', lastName: 'Doe' };
  }
}
```

playgroundã§å†åº¦ã‚¯ã‚¨ãƒªã‚’å®Ÿè¡Œã™ã‚‹ã¨ã€å€¤ãŒè¿”ã£ã¦ãã‚‹ã€‚

```json
{
  "data": {
    "Author": {
      "id": "1",
      "firstName": "John"
    }
  }
}
```

Authorãƒ¡ã‚½ãƒƒãƒ‰ã®Aã‚’å°æ–‡å­—ã«ã™ã‚‹ã¨ä»¥ä¸‹ã®ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã™ã‚‹ã€‚

```ts:Author/author.resolver.ts
@Resolver()
export class AuthorResolver {
  @Query()
  author(@Args('id') id: string): Author {
```

ã‚¨ãƒ©ãƒ¼åŸå› ã¯ãƒªã‚¾ãƒ«ãƒãƒ¼ã«authorã‚¯ã‚¨ãƒªãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ãŒã‚¹ã‚­ãƒ¼ãƒå®šç¾©ã«ã¯å®šç¾©ã•ã‚Œã¦ã„ãªã„ãŸã‚ã€‚
NestJSã®Controllerã®ãƒ¡ã‚½ãƒƒãƒ‰åã¯ä»»æ„ã®åç§°ã§è‰¯ã‹ã£ãŸã€‚
ã—ã‹ã—ã€Resolverã§ã¯ãƒ¡ã‚½ãƒƒãƒ‰åãŒã‚¹ã‚­ãƒ¼ãƒå®šç¾©ã®ã‚¯ã‚¨ãƒªåã¨å¯¾å¿œã—ã¦ã„ãªã„ã¨ã„ã‘ãªã„ã€‚

```sh
Error: Query.author defined in resolvers, but not in schema
```

Authorå‹ã«Postå‹ã®é…åˆ—ã‚’æŒãŸã›ã‚‹ã€‚

```gql:Author/author.graphql
type Author {
  id: ID!
  firstName: String!
  lastName: String!
  posts: [Post]
}

type Post {
  id: ID!
  title: String!
  content: String!
}
```

```gql
query fetch {
  Author(id: "1") {
    id
    firstName
    lastName
    posts {
      id
      title
      content
    }
  }
}
```

postsã«ã¯nullãŒè¿”ã£ã¦ãã‚‹ã€‚

```json
{
  "data": {
    "Author": {
      "id": "1",
      "firstName": "John",
      "lastName": "Doe",
      "posts": null
    }
  }
}
```

`ResolveField`ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’ç”¨ã„ã¦GraphQLå‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼ˆéã‚¹ã‚«ãƒ©ãƒ¼ï¼‰ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å€¤ã‚’è¿”ã™ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ç™»éŒ²ã™ã‚‹ã€‚
æ³¨æ„ç‚¹ã¨ã—ã¦ã€`Resolver`ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ãƒ¼ã«ã€Œã©ã®GraphQLå‹ã«å¯¾å¿œã—ãŸãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãªã®ã‹ã€ã‚’æ˜è¨˜ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚

```ts:author.resolver.ts
@Resolver('Author')
export class AuthorResolver {
  @Query()
  Author(@Args('id') id: string): Author {
    return { id, firstName: 'John', lastName: 'Doe' };
  }

  @ResolveField()
  posts() {
    return [
      {
        id: '1',
        title: 'Post 1',
        content: 'Content 1',
      },
    ];
  }
}
```

å†åº¦ã‚¯ã‚¨ãƒªã‚’é£›ã°ã™ã¨postsã®çµæœãŒè¿”ã£ã¦ãã‚‹ã€‚
`Resolver`ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ãƒ¼ã®å¼•æ•°ã‚’æ¶ˆã™ã¨postsãŒnullã§è¿”ã£ã¦ãã‚‹ã€‚

```json
{
  "data": {
    "Author": {
      "id": "1",
      "firstName": "John",
      "lastName": "Doe",
      "posts": [
        {
          "id": "1",
          "title": "Post 1",
          "content": "Content 1"
        }
      ]
    }
  }
}
```

ãƒ¡ã‚½ãƒƒãƒ‰åã‚’å¤§æ–‡å­—ã«ã™ã‚‹ã¨ä¸‹è¨˜ã®ã‚¨ãƒ©ãƒ¼ãŒè¿”ã£ã¦ãã‚‹ã€‚

```ts:Author/author.resolver.ts
  @ResolveField()
  Posts() {
    return [
      {
        id: '1',
        title: 'Post 1',
        content: 'Content 1',
      },
    ];
  }
```

ãƒªã‚¾ãƒ«ãƒãƒ¼ãŒAuthorå‹ã«Postsãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒã‚ã‚‹å‰æã§ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¦ã„ã‚‹ãŒã€ã‚¹ã‚­ãƒ¼ãƒå®šç¾©ã®Authorå‹ã«ã¯Postsãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒå­˜åœ¨ã—ãªã„ã“ã¨ã‚’è¡¨ã—ã¦ã„ã‚‹ã€‚

```sh
Error: Author.Posts defined in resolvers, but not in schema
```

`Resolver`ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ãƒ¼ã®å¼•æ•°ã«ã‚¹ã‚­ãƒ¼ãƒã«å­˜åœ¨ã—ãªã„å‹åã‚’æ¸¡ã™ã€‚

```ts:Author/author.resolver.ts
@Resolver('author')
export class AuthorResolver {
```

ã‚¹ã‚­ãƒ¼ãƒå®šç¾©ã«å¯¾è±¡ã®å‹ãŒå­˜åœ¨ã—ãªã„ã¨ã®ã‚¨ãƒ©ãƒ¼ãŒå‡ºã‚‹ã€‚

```sh
Error: "author" defined in resolvers, but not in schema
```

Authorãƒ¡ã‚½ãƒƒãƒ‰å´ã§postsã‚’è¿”ã—ã¦ã‚ã’ã¦ã‚‚ã€postsãƒ¡ã‚½ãƒƒãƒ‰å´ã®å€¤ãŒè¿”ã£ã¦ãã‚‹ã€‚
ã¡ãªã¿ã«postsãƒ¡ã‚½ãƒƒãƒ‰ã‹ã‚‰`ResolveField`ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’å¤–ã™ã¨Authorãƒ¡ã‚½ãƒƒãƒ‰å´ã®postsãŒè¿”ã£ã¦ãã‚‹ã€‚

```ts:Author/author.resolver.ts
@Query()
  Author(@Args('id') id: string): Author {
    return { id, firstName: 'John', lastName: 'Doe', posts: [] };
  }
```

`Query`, `ResolveField`ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ãƒ¼ãã‚Œãã‚Œã«ã‚¯ã‚¨ãƒªåã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åã‚’æ¸¡ã™ã“ã¨ã§ãƒ¡ã‚½ãƒƒãƒ‰åã‚’ä»»æ„ã«ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚

```ts:Author/author.resolver.ts
@Query('Author')
  getAuthor(@Args('id') id: string): Author {
    return { id, firstName: 'John', lastName: 'Doe' };
  }

  @ResolveField('posts')
  getPosts() {
    return [
      {
        id: '1',
        title: 'Post 1',
        content: 'Content 1',
      },
    ];
  }
```

# parentå–ã‚Šå‡ºã™

è¦ªã‚¯ã‚¨ãƒªã‹ã‚‰ã®å€¤ã‚’å–ã‚Šå‡ºã™ã“ã¨ãŒã§ãã‚‹ã€‚

```ts:Author/author.resolver.ts
  @ResolveField()
  posts(@Parent() author: Author) {
    return [
      {
        id: '1',
        title: 'Post 1',
        content: `Content 1 from ${author.firstName} ${author.lastName}`,
      },
    ];
  }
```

# ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚¯ãƒ©ã‚¹

```sh
nest g mo Author
```

```ts:Author/author.module.ts
import { Module } from '@nestjs/common';
import { AuthorResolver } from './author.resolver';

@Module({
  providers: [AuthorResolver],
})
export class AuthorModule {}
```

ãƒ«ãƒ¼ãƒˆãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®importsã«AuthorModuleãŒå…¥ã£ã¦ã„ã‚‹ã€‚
AuthorResolverç”Ÿæˆæ™‚ã«providersã«åŠ ãˆã‚‰ã‚Œã¦ã„ãŸã®ã§å‰Šé™¤ã€‚

```ts:app.module.ts

@Module({
  imports: [
    GraphQLModule.forRoot<ApolloDriverConfig>({
      driver: ApolloDriver,
      typePaths: ['./**/*.graphql'],
      definitions: {
        path: join(process.cwd(), 'src/graphql.ts'),
        outputAs: 'class',
      },
    }),
    AuthorModule,
  ],
  controllers: [AppController],
  providers: [AppService, AuthorResolver],
})
export class AppModule {}
```

# ã‚µãƒ¼ãƒ“ã‚¹ã‚¯ãƒ©ã‚¹

```sh
nest g s Author
```

```ts:Author/author.service.ts
@Injectable()
export class AuthorService {
  getAuthor(id: string) {
    return { id, firstName: 'John', lastName: 'Doe' };
  }
}
```

```ts:Author/author.service.ts
@Resolver('Author')
export class AuthorResolver {
  constructor(private readonly authorService: AuthorService) {}

  @Query('Author')
  getAuthor(@Args('id') id: string): Author {
    return this.authorService.getAuthor(id);
  }
```

ã¡ãªã¿ã«è‡ªå‹•ç”Ÿæˆæ™‚ã«Moduleã®providersã«AuthorServiceãŒè¿½åŠ ã•ã‚Œã¦ã„ã‚‹ã€‚
AuthorServiceã‚’å‰Šé™¤ã™ã‚‹ã¨ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã™ã‚‹ã€‚

```ts:Author/author.module.ts
@Module({
  providers: [AuthorResolver],
})
export class AuthorModule {}
```

```sh
Error: Nest can't resolve dependencies of the AuthorResolver (?). Please make sure that the argument AuthorService at index [0] is available in the AuthorModule context.

Potential solutions:
- Is AuthorModule a valid NestJS module?
- If AuthorService is a provider, is it part of the current AuthorModule?
- If AuthorService is exported from a separate @Module, is that module imported within AuthorModule?
  @Module({
    imports: [ /* the Module containing AuthorService */ ]
  })
```

Postã®å‡¦ç†ã‚’åˆ¥ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ç§»å‹•ã™ã‚‹ã€‚

```sh
nest g mo Post
nest g r Post
nest g s Post
```

```ts:Post/post.service.ts
@Injectable()
export class PostService {
  getPosts(author: Author, id: number) {
    return {
      id,
      title: `Post ${id}`,
      content: `Content ${id} from ${author.firstName} ${author.lastName}`,
    };
  }

  getAllPosts(author: Author) {
    return Array.from({ length: 3 }, (_, i) => this.getPosts(author, i);
    );
  }
}
```

```ts:Author/author.resolver.ts
@ResolveField('posts')
  getPosts(@Parent() author: Author) {
    return this.postService.getAllPosts(author);
  }
```

AuthorModuleã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§PostServiceã®ä¾å­˜é–¢ä¿‚ã‚’è§£æ±ºã§ããªã„ã¨ã®ã‚¨ãƒ©ãƒ¼ãŒå‡ºã‚‹ã€‚

```sh
 resolve dependencies of the AuthorResolver (AuthorService, ?). Please make sure that the argument PostService at index [1] is available in the AuthorModule context.

Potential solutions:
- Is AuthorModule a valid NestJS module?
- If PostService is a provider, is it part of the current AuthorModule?
- If PostService is exported from a separate @Module, is that module imported within AuthorModule?
  @Module({
    imports: [ /* the Module containing PostService */ ]
  })
```

ãŸã ã—ã€AuthorModuleã®importsã«ç›´æ¥PostServiceã‚’åŠ ãˆã‚‹ã“ã¨ã¯ã§ããªã„ã€‚

```ts:Author/author.module.ts
@Module({
  imports: [PostService],
  providers: [AuthorResolver, AuthorService],
})
```

```sh
notated with @Injectable(), @Catch(), and @Controller() decorators must not appear in the "imports" array of a module.
Please remove "PostService" (including forwarded occurrences, if any) from all of the "imports" arrays.

Scope [AppModule -> AuthorModule]
```

PostModuleã‚’è¨­å®šã—ã¦ã‚‚ä¾ç„¶ã¨ã—ã¦ä¾å­˜è§£æ±ºã®ã‚¨ãƒ©ãƒ¼ãŒå‡ºã‚‹ã€‚

```ts:Author/author.module.ts
@Module({
  imports: [PostModule],
  providers: [AuthorResolver, AuthorService],
})
```

PostModuleãŒPostServiceã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ã“ã¨ã§ã‚¨ãƒ©ãƒ¼ãŒè§£æ¶ˆã•ã‚Œã‚‹ã€‚

```ts:Post/post.module.ts
@Module({
  providers: [PostResolver, PostService],
  exports: [PostService],
})
```

ã‚¯ã‚¨ãƒªã‚’ç™ºè¡Œã™ã‚‹ã¨ã€å€¤ã‚’å¾—ã‚‹ã“ã¨ãŒã§ããŸã€‚

```json
{
  "data": {
    "Author": {
      "id": "1",
      "firstName": "John",
      "lastName": "Doe",
      "posts": [
        {
          "id": "0",
          "title": "Post 0",
          "content": "Content 0 from John Doe"
        },
        {
          "id": "1",
          "title": "Post 1",
          "content": "Content 1 from John Doe"
        },
        {
          "id": "2",
          "title": "Post 2",
          "content": "Content 2 from John Doe"
        }
      ]
    }
  }
}
```

# ãƒŸãƒ¥ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³

```gql:mutation.graphql
type Mutation {
  createAuthor(firstName: String!, lastName: String!): Author!
  updateAuthor(id: ID!, firstName: String, lastName: String): Author!
  deleteAuthor(id: ID!): Author!
}
```

```ts:Author/author.resolver.ts
  @Mutation('createAuthor')
  createAuthor(
    @Args('firstName') firstName: string,
    @Args('lastName') lastName: string,
  ): Author {
    return this.authorService.createAuthor(firstName, lastName);
  }

  @Mutation('updateAuthor')
  updateAuthor(
    @Args('id') id: string,
    @Args('firstName') firstName: string,
    @Args('lastName') lastName: string,
  ): Author {
    return this.authorService.updateAuthor(id, firstName, lastName);
  }

  @Mutation('deleteAuthor')
  deleteAuthor(@Args('id') id: string): Author {
    return this.authorService.deleteAuthor(id);
  }
```

```ts:Author/author.service.ts
  createAuthor(firstName: string, lastName: string) {
    return { id: '3', firstName, lastName };
  }

  updateAuthor(id: string, firstName: string, lastName: string) {
    return { id, firstName, lastName };
  }

  deleteAuthor(id: string) {
    return { id, firstName: 'John', lastName: 'Doe' };
  }
```

```gql
mutation create {
  createAuthor(firstName: "jim", lastName: "ok") {
    id
    firstName
    lastName
  }
}
```

å›ºå®šã®å€¤ãŒè¿”ã£ã¦ãã‚‹ã€‚

```json
{
  "data": {
    "createAuthor": {
      "id": "3",
      "firstName": "jim",
      "lastName": "ok"
    }
  }
}
```

# Prisma å°å…¥

Prismaã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½¿ã„ã¾ã‚ã›ã‚‹ã‚ˆã†ã«Injectableãªã‚¯ãƒ©ã‚¹ã‚’ä½œæˆã™ã‚‹ã€‚

```sh
npm install prisma --save-dev
npx prisma init
npm install @prisma/client
```

```yml:docker.compose.yml
version: "3.7"
services:
  db:
    container_name: postgres
    image: postgres:13
    ports:
      - "5432:5432"
    command: postgres -c log_destination=stderr -c log_statement=all -c log_connections=on -c log_disconnections=on
    environment:
      - POSTGRES_PASSWORD=postgres
    logging:
      options:
        max-size: "10k"
        max-file: "5"
```

```sh
docker-compose up
```

```:.env
DATABASE_URL="postgresql://postgres:postgres@localhost:5432/mydb?schema=public"
```

```sh
npx prisma migrate dev --name init
```

```ts:prisma.service.ts
import { Injectable, OnModuleInit } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit {
  async onModuleInit() {
    await this.$connect();
  }
}
```

```ts:Author.author.service.ts

@Injectable()
export class AuthorService {
  constructor(private readonly prismaService: PrismaService) {}
  async getAuthor(id: string) {
    return await this.prismaService.author.findUnique({
      where: { id },
    });
  }

  async createAuthor(firstName: string, lastName: string) {
    return await this.prismaService.author.create({
      data: {
        firstName,
        lastName,
      },
    });
  }

  async updateAuthor(id: string, firstName: string, lastName: string) {
    return await this.prismaService.author.update({
      where: { id },
      data: {
        firstName,
        lastName,
      },
    });
  }

  async deleteAuthor(id: string) {
    return await this.prismaService.author.delete({
      where: { id },
    });
  }
}
```

PrismaServiceã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒæä¾›ã•ã‚Œã¦ã„ãªã„ã®ã§ã€providersã«ç›´æ¥æŒ‡å®šã™ã‚‹ã€‚

```ts:Author/author.module.ts
@Module({
  imports: [PostModule],
  providers: [AuthorResolver, AuthorService, PrismaService],
})
export class AuthorModule {}
```

PrismaClientãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ãªã„ã¨ã®ã‚¨ãƒ©ãƒ¼ãŒè¡¨ç¤ºã•ã‚Œã‚‹ã€‚

```prisma:schema.prisma
model Author {
  id        String  @id @db.Uuid() @default(uuid())
  firstName String  @db.VarChar(255)
  lastName  String  @db.VarChar(255)
}
```

```sh
npx prisma generate
npx prisma migrate dev
npx prisma studio
```

ä»¥ä¸‹ã§Authorã‚’ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«è¿½åŠ ã§ãã‚‹ã€‚
http://localhost:5555/ã‹ã‚‰Prisma Studioã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã€AuthorãŒè¿½åŠ ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèªã§ãã‚‹ã€‚

```gql
mutation create {
  createAuthor(firstName: "jim", lastName: "ok") {
    id
    firstName
    lastName
  }
}
```

```gql
type Post {
  id: ID!
  title: String!
  content: String!
  authorId: ID!
  author: Author!
}
```

```prisma:schema.prisma
model Author {
  id        String  @id @db.Uuid() @default(uuid())
  firstName String  @db.VarChar(255)
  lastName  String  @db.VarChar(255)
  posts     Post[]
}

model Post {
  id      String   @id @db.Uuid() @default(uuid())
  title   String   @db.VarChar(255)
  content String   @db.Text()
  author  Author   @relation(fields: [authorId], references: [id])
  authorId String  @db.Uuid()
}
```

```sh
npx prisma migrate dev
```

```gql:mutation.graphql
type Mutation {
  createAuthor(firstName: String!, lastName: String!): Author!
  updateAuthor(id: ID!, firstName: String, lastName: String): Author!
  deleteAuthor(id: ID!): Author!
  createPost(authorId: ID!, title: String!, content: String!): Post!
}
```

```ts:Post/post.module.ts
@Module({
  providers: [PostResolver, PostService, PrismaService],
  exports: [PostService],
})
```

```ts:Post/resolver.ts
@Resolver()
export class PostResolver {
  constructor(private readonly postService: PostService) {}

  @Mutation('createPost')
  createPost(
    @Args('authorId') authorId: string,
    @Args('title') title: string,
    @Args('content') content: string,
  ) {
    return this.postService.createPost(authorId, title, content);
  }
}
```

```ts:Post/post.service.ts
  createPost(authorId: string, title: string, content: string) {
    return this.prismaService.post.create({
      data: {
        authorId,
        title,
        content,
      },
    });
  }
```

ä»¥ä¸‹ãƒŸãƒ¥ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œã™ã‚‹ã¨ã€Prisma Studioã«ãƒ¬ã‚³ãƒ¼ãƒ‰ãŒè¿½åŠ ã•ã‚Œã¦ã„ã‚‹ã€‚

```gql
mutation CreatePost {
  createPost(authorId: "5491a0b0-32b9-49ea-8215-e014e9cbec3c", title: "ã“ã‚“ã«ã¡ã¯", content: "åˆã‚ã¦ã®æŠ•ç¨¿ã§ã™ã€‚") {
    id
    title
    content
  }
}
```

ã—ã‹ã—ã€authorã‚’å–å¾—ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã™ã‚‹ã€‚

```gql
mutation CreatePost {
  createPost(authorId: "5491a0b0-32b9-49ea-8215-e014e9cbec3c", title: "ã“ã‚“ã«ã¡ã¯", content: "åˆã‚ã¦ã®æŠ•ç¨¿ã§ã™ã€‚") {
    id
    title
    content
    author {
      id
      firstName
      lastName
    }
  }
}
```

```json
{
  "error": {
    "errors": [
      {
        "message": "Cannot query field \"author\" on type \"Post\".",
        "locations": [
          {
            "line": 26,
            "column": 5
          }
        ],
        "extensions": {
          "code": "GRAPHQL_VALIDATION_FAILED",
          "stacktrace": [
            "GraphQLError: Cannot query field \"author\" on type \"Post\".",
            ...
          ]
        }
      }
    ]
  }
```

```ts:Post/post.module.ts
@Module({
  imports: [AuthorModule],
  providers: [PostResolver, PostService, PrismaService],
  exports: [PostService],
})
export class PostModule {}
```

AuthorModuleã§ã‚‚PostModuleã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ãŸã‚ä¾å­˜å¾ªç’°ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã™ã‚‹ã€‚

```sh
ERROR [ExceptionHandler] Nest cannot create the PostModule instance.
The module at index [0] of the PostModule "imports" array is undefined.

Potential causes:
- A circular dependency between modules. Use forwardRef() to avoid it. Read more: https://docs.nestjs.com/fundamentals/circular-dependency
- The module at index [0] is of type "undefined". Check your import statements and the type of the module.
```

ç›´æ¥ã‚µãƒ¼ãƒ“ã‚¹ã‚’providersã«åŠ ãˆã‚‹ã€‚

```ts:Post/post.module.ts
@Module({
  providers: [PostResolver, PostService, PrismaService, AuthorService],
  exports: [PostService],
})
export class PostModule {}
```

```ts:Post/post.resolver.ts
  @ResolveField('author')
  getAuthor(@Parent() post: Post) {
    return this.authorService.getAuthor(post.authorId);
  }
```

authorãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å€¤ã‚’ã‚¯ã‚¨ãƒªã™ã‚‹ã“ã¨ãŒã§ããŸã€‚

```json
{
  "data": {
    "createPost": {
      "id": "7be06002-4bf4-4992-8bf2-d7d0da3e9a56",
      "title": "ã“ã‚“ã«ã¡ã¯",
      "content": "åˆã‚ã¦ã®æŠ•ç¨¿ã§ã™ã€‚",
      "author": {
        "id": "5491a0b0-32b9-49ea-8215-e014e9cbec3c",
        "firstName": "jim",
        "lastName": "ok"
      }
    }
  }
}
```

```gql
query fetch {
  Author(id: "5491a0b0-32b9-49ea-8215-e014e9cbec3c") {
    id
    firstName
    lastName
    posts {
      id
      title
      content
    }
  }
}
```

```ts:Post/post.resolver.ts
  @ResolveField('posts')
  getPosts(@Parent() author: Author) {
    return this.postService.getAllPostsByAuthorId(author.id);
  }
```

```ts:Post/post.service.ts
  getAllPostsByAuthorId(authorId: string) {
    return this.prismaService.post.findMany({
      where: {
        authorId,
      },
    });
  }
```

```json
{
  "data": {
    "Author": {
      "id": "5491a0b0-32b9-49ea-8215-e014e9cbec3c",
      "firstName": "jim",
      "lastName": "ok",
      "posts": [
        {
          "id": "effde148-8910-4e97-b662-8ee5ff85c80c",
          "title": "ã“ã‚“ã«ã¡ã¯",
          "content": "åˆã‚ã¦ã®æŠ•ç¨¿ã§ã™ã€‚"
        },
      ]
    }
  }
}
```

# ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢
# ãƒ‘ã‚¤ãƒ—
# ä¾‹å¤–ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼
# ã‚¤ãƒ³ã‚¿ãƒ¼ã‚»ãƒ—ã‚¿ãƒ¼
# ã‚¬ãƒ¼ãƒ‰
# Zodå°å…¥
