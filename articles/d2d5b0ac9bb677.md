---
title: ""
emoji: "😎"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---
前提
ブラウザの主要機能は、ユーザーのURLの入力を受け付けてHTTPプロトコルを利用してHTMLファイルを取得し表示すること
HTMLファイル自体はインタラクティブな操作をネットワーク処理なしで実現できない
ネットワークを介さないインタラクティブな操作を実現するため、scriptタグにJavaScriptでブラウザが提供するDOM操作を記述する
scriptタグの肥大化を防ぐため、一般にはJavaScriptファイルにDOM操作を記述し、HTMLファイルにscriptタグを埋め込んでJavaScriptファイルを紐付ける
ファイル読み込み順は常に、HTMLファイル→JavaScriptファイルとなる
メインスレッドがJavaScriptファイルを読み込み、DOM操作を実行する

非同期処理とは
コードの記述順と異なる順番でメインスレッドが実行する処理

非同期処理の目的
時間のかかる処理によってメインの処理を止めない、かつ時間のかかる処理を起点とした後続処理の実行順を担保するため
- 時間のかかる処理: ファイル読み書き、タイマー処理、ネットワーク処理
- メインの処理: JSファイルの読み込み、UI更新[?]

ブラウザ実行環境の初回JavaScriptファイル読み込み時に限定して、実現したいことを整理 (実際はイベントハンドラーなど初回読み込み以外でもメインスレッドの処理は発生する場合がある)
- 5秒後待ってからある処理を実行
  - メインスレッドがJavaScriptファイルを読み込む
  - メインスレッドが5秒待つ処理を見つけたら別の担当者にタイマー処理を任せる
  - タイマー処理を任せている間、メインスレッドは時間のかかる処理を後回しにしてJavaScriptファイル読み込み処理を継続する
  - 別の担当者が5秒待ったらメインスレッドに次の処理を実行させる
- Web上のjsonコンテンツをHTTP GETメソッドで取得して、表示する
  - メインスレッドがJavaScriptファイルを読み込む
  - メインスレッドがWeb上のjsonコンテンツをHTTP GETメソッドで取得する処理を見つけたら別の担当者にネットワーク処理を任せる
  - タイマー処理を任せている間、メインスレッドは時間のかかる処理を後回しにしてJavaScriptファイル読み込み処理を継続する
  - 別の担当者がjsonコンテンツを取得したらメインスレッドにjsonコンテンツとその表示処理を実行させる
↓
やりたいことテンプレート
- メインスレッドがJavaScriptファイルを読み込む
- メインスレッドが`時間がかかる処理A`を見つけたら別の担当者に`処理A`を任せる
- タイマー処理を任せている間、メインスレッドは時間のかかる処理を後回しにしてJavaScriptファイル読み込み処理を継続する
- 別の担当者が`処理A`を完了したらメインスレッドに`処理Aの結果`を用いて`後続処理B`を実行させる

実現できないといけないことを整理
- メインスレッドは`時間がかかる処理A`の適切な担当者を探し出し処理を委譲
- 担当者は`時間がかかる処理A`を実行する
- メインスレッドはメイン処理を継続する
- 担当者が`時間がかかる処理A`を完了したらメインスレッドに`処理が完了したこと`と`処理Aの結果`と`続きの処理`を通知する
- メインスレッドは適切なタイミングを見計らって`続きの処理`を実行する

非同期処理をどう実現しているか
- メインスレッドは`時間がかかる処理A`の適切な担当者を探し出し処理を委譲
  - 環境がメインスレッドと別のプロセス・スレッドを持ち、時間がかかる処理ごとに担当スレッドを用意
  - 環境が時間のかかる処理を実行するための非同期API (Web API, Runtime API) を提供し、APIを呼び出すと担当スレッドに処理を行わせる
    - 種類
      - マイクロタスクを発行する非同期API
        - コールバックをマイクロタスクとして発行する非同期API
        - Promiseインスタンスを返しそのインスタンスの中にAPIの処理結果を入れておく非同期API
      - タスクベースの非同期API
        - scriptトップレベルのコードもタスクの一種
    - 非同期API自体はメインスレッドが同期的に呼び出し、ワーカースレッドがメインスレッドと並列的に実行し、結果的に非同期になりうるのは登録したコールバック関数
  - メインスレッドが処理を開始する前に、グローバル実行コンテキストを生成し、それをスタックフレームに関連づけてスタックフレームをコールスタックに積み、実行コンテキストに時間のかかる処理を実行するためのAPIを紐づける
    - 実行コンテキストはJavaScriptのオブジェクト、JavaScriptエンジンが生成する
      - 変数オブジェクト: 関数内で定義された変数(関数を含む)の情報を持つ
      - スコープチェーン: 変数オブジェクトを参照するための構造。ネストされた関数内で現在の実行コンテキストの外の変数にアクセスできる。
      - thisの値: 現在の実行コンテキストに関連するオブジェクト。
      - 実行対象のコード
    - 実行中の実行コンテキストはコールスタックの最上位
- 担当者は`時間がかかる処理A`を実行する
  - API呼び出しを受けると担当スレッドが処理を実行
- メインスレッドはメイン処理を継続する
  - 時間のかかる処理を実行するためのAPIを呼び出したらコールスタックからフレームをポップする
- 担当者が`時間がかかる処理A`を完了したらメインスレッドに`処理が完了したこと`と`処理Aの結果`と`続きの処理`を通知する
  - 時間のかかる処理を実行するためのAPIには後続処理をコールバックとして登録するシグネチャが付いている
  - タスクキューというメインスレッドのTo Doリストがある
  - イベントループという処理をメインスレッドが実行することでメインスレッドがタスクキューに積まれているタスクをコールスタックに移動し実行することができる
- メインスレッドは適切なタイミングを見計らって`続きの処理`を実行する

非同期処理をブラウザのどの機構が実現しているか

疑問
- なぜブラウザはシングルスレッドじゃないといけない？
  - いけないことはないが、歴史的経緯でシングルスレッド
  - ブラウザ誕生時はマルチプロセッサーデバイスが少なかった
  - 現在はWebWorker APIがあるのでJSを実行できるスレッドは

https://zenn.dev/canalun/articles/js_async_and_company
https://zenn.dev/qnighy/articles/345aa9cae02d9d
